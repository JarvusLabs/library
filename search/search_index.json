{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 The Jarvus Labs\u2019 Library serves as a hub for Jarvus\u2019 open know-how.","title":"Welcome"},{"location":"#welcome","text":"The Jarvus Labs\u2019 Library serves as a hub for Jarvus\u2019 open know-how.","title":"Welcome"},{"location":"kubernetes/shared-clusters/create-cluster/","text":"Create a cluster \u00b6 Coming soon For now, see: cluster-template : Jarvus\u2019 public template for lightweight, self-sufficient, multi-project Kubernetes clusters. jarvus-sandbox-cluster : If you have access, this repository demonstrates the setup documented in this section. Create GitHub token for deploy workflows \u00b6 The GitHub Actions deployment workflow requires a GitHub bot user to write to the cluster repository with. This is necessary so that a branch pushed by the GitHub Actions workflow can trigger subsequent workflows. The authentication tokens that are automatically provided to all GitHub Actions workflow runs are able to push to the host repository, but their pushes are prevented from triggering any workflows. Create or reuse GitHub bot user with write access to the cluster repository Grant the GitHub bot user the write access to the cluster repository, and ensure that its invitation is accepted Create a Personal Access Token under the GitHub bot user with repo scope Save the generated Personal Access Token to a secret called BOT_GITHUB_TOKEN under the cluster repository Create service account \u00b6 The GitHub Actions Workflows driving deployments will need a service account with read/write access to all namespaces. Add this manifest to the cluster\u2019s GitHub repository under e.g. deployers/cluster.yaml where it will become part of the automated deployment, but you will need to apply it to the cluster manually ahead of the first automated deployment: deployers/cluster.yaml apiVersion : v1 kind : ServiceAccount metadata : name : cluster-deployer namespace : kube-system --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cluster-deployer rules : - apiGroups : [ \"*\" ] resources : [ \"*\" ] verbs : [ \"*\" ] --- kind : RoleBinding apiVersion : rbac.authorization.k8s.io/v1beta1 metadata : name : cluster-deployer namespace : kube-system roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-deployer subjects : - kind : ServiceAccount name : cluster-deployer namespace : kube-system mkkubeconfig #!/bin/bash # adapted from: https://gist.github.com/ericchiang/d2a838ddad3f44436ae001a342e1001e TEMPDIR = $( mktemp -d ) trap \"{ rm -rf $TEMPDIR ; exit 255; }\" EXIT SA_SECRET = $( kubectl get sa -n $1 $2 -o jsonpath = '{.secrets[0].name}' ) # Pull the bearer token and cluster CA from the service account secret. BEARER_TOKEN = $( kubectl get secrets -n $1 $SA_SECRET -o jsonpath = '{.data.token}' | base64 -d ) kubectl get secrets -n $1 $SA_SECRET -o jsonpath = '{.data.ca\\.crt}' | base64 -d > $TEMPDIR /ca.crt CLUSTER_URL = $( kubectl config view -o jsonpath = '{.clusters[0].cluster.server}' ) KUBECONFIG = $TEMPDIR /kubeconfig.yaml 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-cluster \\ $CLUSTER_URL \\ --server = $CLUSTER_URL \\ --certificate-authority = $TEMPDIR /ca.crt \\ --embed-certs = true 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-credentials $2 --token = $BEARER_TOKEN 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-context registry \\ --cluster = $CLUSTER_URL \\ --user = $2 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ use-context registry cat $KUBECONFIG Apply manifests to create service account: kubectl apply -f deployers/cluster.yaml Use provided script to generate a base64-encoded KUBECONFIG for GitHub: ./mkkubeconfig kube-system cluster-deployer | base64 Save the base64 blob output above to a secret called KUBECONFIG_BASE64 under the cluster repository Create GitHub token for cluster image pulls \u00b6 If deployments will utilize Docker container images uploaded to GitHub\u2019s Packages registry, the deployment workflow can handle injecting these into any desired namespace. Create or reuse GitHub bot user with write access to the cluster repository Grant the GitHub bot user write access to the cluster repository, and ensure that its invitation is accepted Create a Personal Access Token under the GitHub bot user with the read:packages scope Generate a base64-encoded .docker/config.json file: echo -n 'Username: ' && read github_username echo -n 'Password: ' && read -s github_token echo && echo \"{ \\\"auths\\\": { \\\"docker.pkg.github.com\\\": { \\\"auth\\\": \\\" $( echo -n \" ${ github_username } : ${ github_token } \" | base64 ) \\\" } } }\" | base64 Save the generated base64 blob to a secret called DOCKER_CONFIG_BASE64 under the cluster repository","title":"Create a cluster"},{"location":"kubernetes/shared-clusters/create-cluster/#create-a-cluster","text":"Coming soon For now, see: cluster-template : Jarvus\u2019 public template for lightweight, self-sufficient, multi-project Kubernetes clusters. jarvus-sandbox-cluster : If you have access, this repository demonstrates the setup documented in this section.","title":"Create a cluster"},{"location":"kubernetes/shared-clusters/create-cluster/#create-github-token-for-deploy-workflows","text":"The GitHub Actions deployment workflow requires a GitHub bot user to write to the cluster repository with. This is necessary so that a branch pushed by the GitHub Actions workflow can trigger subsequent workflows. The authentication tokens that are automatically provided to all GitHub Actions workflow runs are able to push to the host repository, but their pushes are prevented from triggering any workflows. Create or reuse GitHub bot user with write access to the cluster repository Grant the GitHub bot user the write access to the cluster repository, and ensure that its invitation is accepted Create a Personal Access Token under the GitHub bot user with repo scope Save the generated Personal Access Token to a secret called BOT_GITHUB_TOKEN under the cluster repository","title":"Create GitHub token for deploy workflows"},{"location":"kubernetes/shared-clusters/create-cluster/#create-service-account","text":"The GitHub Actions Workflows driving deployments will need a service account with read/write access to all namespaces. Add this manifest to the cluster\u2019s GitHub repository under e.g. deployers/cluster.yaml where it will become part of the automated deployment, but you will need to apply it to the cluster manually ahead of the first automated deployment: deployers/cluster.yaml apiVersion : v1 kind : ServiceAccount metadata : name : cluster-deployer namespace : kube-system --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cluster-deployer rules : - apiGroups : [ \"*\" ] resources : [ \"*\" ] verbs : [ \"*\" ] --- kind : RoleBinding apiVersion : rbac.authorization.k8s.io/v1beta1 metadata : name : cluster-deployer namespace : kube-system roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-deployer subjects : - kind : ServiceAccount name : cluster-deployer namespace : kube-system mkkubeconfig #!/bin/bash # adapted from: https://gist.github.com/ericchiang/d2a838ddad3f44436ae001a342e1001e TEMPDIR = $( mktemp -d ) trap \"{ rm -rf $TEMPDIR ; exit 255; }\" EXIT SA_SECRET = $( kubectl get sa -n $1 $2 -o jsonpath = '{.secrets[0].name}' ) # Pull the bearer token and cluster CA from the service account secret. BEARER_TOKEN = $( kubectl get secrets -n $1 $SA_SECRET -o jsonpath = '{.data.token}' | base64 -d ) kubectl get secrets -n $1 $SA_SECRET -o jsonpath = '{.data.ca\\.crt}' | base64 -d > $TEMPDIR /ca.crt CLUSTER_URL = $( kubectl config view -o jsonpath = '{.clusters[0].cluster.server}' ) KUBECONFIG = $TEMPDIR /kubeconfig.yaml 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-cluster \\ $CLUSTER_URL \\ --server = $CLUSTER_URL \\ --certificate-authority = $TEMPDIR /ca.crt \\ --embed-certs = true 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-credentials $2 --token = $BEARER_TOKEN 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ set-context registry \\ --cluster = $CLUSTER_URL \\ --user = $2 1 > & 2 kubectl config --kubeconfig = $KUBECONFIG \\ use-context registry cat $KUBECONFIG Apply manifests to create service account: kubectl apply -f deployers/cluster.yaml Use provided script to generate a base64-encoded KUBECONFIG for GitHub: ./mkkubeconfig kube-system cluster-deployer | base64 Save the base64 blob output above to a secret called KUBECONFIG_BASE64 under the cluster repository","title":"Create service account"},{"location":"kubernetes/shared-clusters/create-cluster/#create-github-token-for-cluster-image-pulls","text":"If deployments will utilize Docker container images uploaded to GitHub\u2019s Packages registry, the deployment workflow can handle injecting these into any desired namespace. Create or reuse GitHub bot user with write access to the cluster repository Grant the GitHub bot user write access to the cluster repository, and ensure that its invitation is accepted Create a Personal Access Token under the GitHub bot user with the read:packages scope Generate a base64-encoded .docker/config.json file: echo -n 'Username: ' && read github_username echo -n 'Password: ' && read -s github_token echo && echo \"{ \\\"auths\\\": { \\\"docker.pkg.github.com\\\": { \\\"auth\\\": \\\" $( echo -n \" ${ github_username } : ${ github_token } \" | base64 ) \\\" } } }\" | base64 Save the generated base64 blob to a secret called DOCKER_CONFIG_BASE64 under the cluster repository","title":"Create GitHub token for cluster image pulls"},{"location":"kubernetes/shared-clusters/deploy-project/","text":"Deploying a project \u00b6 Prerequisites \u00b6 An operational shared cluster A working Dockerfile at the root of the project repository Setup \u00b6 Publish Docker container via GitHub \u00b6 Within the project\u2019s GitHub repository: Build a Helm 3 chart at in a helm-chart/ directory at the root of the project Define a holobranch named helm-chart that outputs the contents of the helm-chart/ directory Create a GitHub Actions workflow triggered by v* tags to build and publish a Docker container image to the project\u2019s GitHub Packages Create project deployment directory \u00b6 Within the shared cluster\u2019s GitHub repository, create a top-level directory naming this project deployment: mkdir client-project Set up release values \u00b6 Inside the project deployment directory created in the cluster\u2019s repository above, create a YAML file to hold deployment-specific overrides to the Helm chart\u2019s values.yaml , including at least the current image+tag: client-project/release.yaml image : docker.pkg.github.com/jarvusinnovations/client-project/client-project:v1.2.3\" This will be where the image version gets bumped to deploy new versions to the shared cluster. You can add any other instance-specific overrides like hostnames as well. Populate deployment directory with project\u2019s helm-chart projection \u00b6 Still within the shared cluster\u2019s GitHub repository, define a holosource and holomapping to populate the project\u2019s directory created above with content from the project\u2019s helm-chart projection: .holo/sources/client-project.toml [holosource] url = \"https://github.com/JarvusInnovations/client-project.git\" ref = \"refs/heads/deploy\" .holo/branches/k8s-manifests/client-project.toml [holomapping] holosource = \"=>helm-chart\" files = \"**\" During the projection of the cluster\u2019s k8s-manifests holobranch, the client-project directory will be populated from the remote helm-chart holobranch from the client-project holosource. The identically-named directory within the cluster\u2019s repository is then overlaid on top via an existing holomapping to copy all the cluster repository\u2019s overrides with after = \"*\" configured. Test composition \u00b6 To test the set up so far, project the k8s-manifests holobranch without lensing and list the full contents of the resulting project deployment directory: git ls-tree -r $( git holo project --working --no-lens k8s-manifests ) :client-project The output should include Chart.yaml , values.yaml , and templates/ from the project repository\u2019s helm-chart sources, plus the release.yaml file from the shared cluster repository\u2019s overrides directory: info: indexing working tree (this can take a while under Docker)... ... info: writing final output tree... info: projection ready 100644 blob 539bef2f8faea713a589ffabf97f094314faaf44 Chart.yaml 100644 blob dbf8c7a6ffc8edd87788ef885adf68cbf556f238 release.yaml 100644 blob dfcff8182969fe2db44037ed1c3a582b362bcdcc templates/_helpers.tpl 100644 blob e7e1a8bbbb63dc859dbf283557c413ae3e7c776f templates/cronjob.yaml 100644 blob 8fd6234ea1b1e2b04e469ef8ea31a860ec068901 templates/deployment.yaml 100644 blob b0c972120c53b742397d9032a8e14222b2aa14ef templates/ingress.yaml 100644 blob 0b2daeff5d1416eb981d6fa03dba5eabbebb6e73 templates/pvc.yaml 100644 blob 51ecaa3981401a8f20f56c458d92a9e46a3b3b8c templates/service.yaml 100644 blob 9a7fb93863e295ee8f059f3607840d7bf222b98d values.yaml Define hololens to build chart \u00b6 Finally, define a lens that uses helm template to transform the combined Helm chart content to deploy-ready Kubernetes manifests: .holo/lenses/client-project.toml [hololens] package = \"holo/lens-helm3/1.2\" [hololens.input] root = \"client-project\" files = \"**\" [hololens.output] merge = \"replace\" [hololens.helm] release_name = \"client-project\" namespace = \"client\" namespace_fill = true chart_path = \".\" value_files = [ \"values.yaml\" , \"release.yaml\" ] Test composition+lensing \u00b6 To test the full manifest generation process, first sync your local k8s/deploy branch to the current remote version: git update-ref refs/heads/k8s/deploy origin/k8s/deploy Then commit the projected k8s-manifests holobranch with lensing on top to preview how it will be extended: git holo project k8s-manifests-github --working --commit-to = k8s/deploy Add GitHub credentials to new namespace \u00b6 Authentication is always required to pull Docker images from GitHub Packages, even when the project repository is public. Wherever the project\u2019s Helm chart templates reference the project\u2019s Docker container image published on GitHub, imagePullSecrets should be configured to use a secret named regcred . The shared cluster\u2019s .github/workflows/deploy-manifests.yml workflow must then be edited to add a line with the new project namespace to the REGCRED_NAMESPACES env value. With that, the workflow will handle generating a regcred secret with access to GitHub in each namespace to include in every deployment. Authenticate access to private project sources \u00b6 If the project\u2019s repository is private, an additional step must be taken to grant fetch access to the GitHub Actions workflow running under the shared cluster\u2019s repository. Edit the shared cluster\u2019s .github/workflows/build-manifests.yml workflow and add an environment variable to the manifests projection step overriding the named source with an authenticated Git remote URL: # ... jobs : build-manifests : # ... steps : - name : 'Update holobranch: k8s/manifests' uses : JarvusInnovations/hologit@actions/projector/v1 env : # ... HOLO_SOURCE_CLIENT_PROJECT : https://jarvus-bot:${{ secrets.BOT_GITHUB_TOKEN }}@github.com/JarvusInnovations/client-project.git The bot user must be granted read access to the repository.","title":"Deploying a project"},{"location":"kubernetes/shared-clusters/deploy-project/#deploying-a-project","text":"","title":"Deploying a project"},{"location":"kubernetes/shared-clusters/deploy-project/#prerequisites","text":"An operational shared cluster A working Dockerfile at the root of the project repository","title":"Prerequisites"},{"location":"kubernetes/shared-clusters/deploy-project/#setup","text":"","title":"Setup"},{"location":"kubernetes/shared-clusters/deploy-project/#publish-docker-container-via-github","text":"Within the project\u2019s GitHub repository: Build a Helm 3 chart at in a helm-chart/ directory at the root of the project Define a holobranch named helm-chart that outputs the contents of the helm-chart/ directory Create a GitHub Actions workflow triggered by v* tags to build and publish a Docker container image to the project\u2019s GitHub Packages","title":"Publish Docker container via GitHub"},{"location":"kubernetes/shared-clusters/deploy-project/#create-project-deployment-directory","text":"Within the shared cluster\u2019s GitHub repository, create a top-level directory naming this project deployment: mkdir client-project","title":"Create project deployment directory"},{"location":"kubernetes/shared-clusters/deploy-project/#set-up-release-values","text":"Inside the project deployment directory created in the cluster\u2019s repository above, create a YAML file to hold deployment-specific overrides to the Helm chart\u2019s values.yaml , including at least the current image+tag: client-project/release.yaml image : docker.pkg.github.com/jarvusinnovations/client-project/client-project:v1.2.3\" This will be where the image version gets bumped to deploy new versions to the shared cluster. You can add any other instance-specific overrides like hostnames as well.","title":"Set up release values"},{"location":"kubernetes/shared-clusters/deploy-project/#populate-deployment-directory-with-projects-helm-chart-projection","text":"Still within the shared cluster\u2019s GitHub repository, define a holosource and holomapping to populate the project\u2019s directory created above with content from the project\u2019s helm-chart projection: .holo/sources/client-project.toml [holosource] url = \"https://github.com/JarvusInnovations/client-project.git\" ref = \"refs/heads/deploy\" .holo/branches/k8s-manifests/client-project.toml [holomapping] holosource = \"=>helm-chart\" files = \"**\" During the projection of the cluster\u2019s k8s-manifests holobranch, the client-project directory will be populated from the remote helm-chart holobranch from the client-project holosource. The identically-named directory within the cluster\u2019s repository is then overlaid on top via an existing holomapping to copy all the cluster repository\u2019s overrides with after = \"*\" configured.","title":"Populate deployment directory with project's helm-chart projection"},{"location":"kubernetes/shared-clusters/deploy-project/#test-composition","text":"To test the set up so far, project the k8s-manifests holobranch without lensing and list the full contents of the resulting project deployment directory: git ls-tree -r $( git holo project --working --no-lens k8s-manifests ) :client-project The output should include Chart.yaml , values.yaml , and templates/ from the project repository\u2019s helm-chart sources, plus the release.yaml file from the shared cluster repository\u2019s overrides directory: info: indexing working tree (this can take a while under Docker)... ... info: writing final output tree... info: projection ready 100644 blob 539bef2f8faea713a589ffabf97f094314faaf44 Chart.yaml 100644 blob dbf8c7a6ffc8edd87788ef885adf68cbf556f238 release.yaml 100644 blob dfcff8182969fe2db44037ed1c3a582b362bcdcc templates/_helpers.tpl 100644 blob e7e1a8bbbb63dc859dbf283557c413ae3e7c776f templates/cronjob.yaml 100644 blob 8fd6234ea1b1e2b04e469ef8ea31a860ec068901 templates/deployment.yaml 100644 blob b0c972120c53b742397d9032a8e14222b2aa14ef templates/ingress.yaml 100644 blob 0b2daeff5d1416eb981d6fa03dba5eabbebb6e73 templates/pvc.yaml 100644 blob 51ecaa3981401a8f20f56c458d92a9e46a3b3b8c templates/service.yaml 100644 blob 9a7fb93863e295ee8f059f3607840d7bf222b98d values.yaml","title":"Test composition"},{"location":"kubernetes/shared-clusters/deploy-project/#define-hololens-to-build-chart","text":"Finally, define a lens that uses helm template to transform the combined Helm chart content to deploy-ready Kubernetes manifests: .holo/lenses/client-project.toml [hololens] package = \"holo/lens-helm3/1.2\" [hololens.input] root = \"client-project\" files = \"**\" [hololens.output] merge = \"replace\" [hololens.helm] release_name = \"client-project\" namespace = \"client\" namespace_fill = true chart_path = \".\" value_files = [ \"values.yaml\" , \"release.yaml\" ]","title":"Define hololens to build chart"},{"location":"kubernetes/shared-clusters/deploy-project/#test-compositionlensing","text":"To test the full manifest generation process, first sync your local k8s/deploy branch to the current remote version: git update-ref refs/heads/k8s/deploy origin/k8s/deploy Then commit the projected k8s-manifests holobranch with lensing on top to preview how it will be extended: git holo project k8s-manifests-github --working --commit-to = k8s/deploy","title":"Test composition+lensing"},{"location":"kubernetes/shared-clusters/deploy-project/#add-github-credentials-to-new-namespace","text":"Authentication is always required to pull Docker images from GitHub Packages, even when the project repository is public. Wherever the project\u2019s Helm chart templates reference the project\u2019s Docker container image published on GitHub, imagePullSecrets should be configured to use a secret named regcred . The shared cluster\u2019s .github/workflows/deploy-manifests.yml workflow must then be edited to add a line with the new project namespace to the REGCRED_NAMESPACES env value. With that, the workflow will handle generating a regcred secret with access to GitHub in each namespace to include in every deployment.","title":"Add GitHub credentials to new namespace"},{"location":"kubernetes/shared-clusters/deploy-project/#authenticate-access-to-private-project-sources","text":"If the project\u2019s repository is private, an additional step must be taken to grant fetch access to the GitHub Actions workflow running under the shared cluster\u2019s repository. Edit the shared cluster\u2019s .github/workflows/build-manifests.yml workflow and add an environment variable to the manifests projection step overriding the named source with an authenticated Git remote URL: # ... jobs : build-manifests : # ... steps : - name : 'Update holobranch: k8s/manifests' uses : JarvusInnovations/hologit@actions/projector/v1 env : # ... HOLO_SOURCE_CLIENT_PROJECT : https://jarvus-bot:${{ secrets.BOT_GITHUB_TOKEN }}@github.com/JarvusInnovations/client-project.git The bot user must be granted read access to the repository.","title":"Authenticate access to private project sources"}]}