{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 The Jarvus Labs\u2019 Library serves as a hub for Jarvus\u2019 open know-how.","title":"Welcome"},{"location":"#welcome","text":"The Jarvus Labs\u2019 Library serves as a hub for Jarvus\u2019 open know-how.","title":"Welcome"},{"location":"kubernetes/shared-clusters/create-cluster/","text":"Create a cluster \u00b6 Coming soon For now, see: cluster-template : Jarvus\u2019 public template for lightweight, self-sufficient, multi-project Kubernetes clusters. jarvus-sandbox-cluster : If you have access, this repository demonstrates the setup documented in this section.","title":"Create a cluster"},{"location":"kubernetes/shared-clusters/create-cluster/#create-a-cluster","text":"Coming soon For now, see: cluster-template : Jarvus\u2019 public template for lightweight, self-sufficient, multi-project Kubernetes clusters. jarvus-sandbox-cluster : If you have access, this repository demonstrates the setup documented in this section.","title":"Create a cluster"},{"location":"kubernetes/shared-clusters/deploy-project/","text":"Deploying a project \u00b6 Prerequisites \u00b6 A working Dockerfile at the root of the project repository Setup \u00b6 Publish Docker container via GitHub \u00b6 Within the project\u2019s GitHub repository: Build a Helm 3 chart at in a helm-chart/ directory at the root of the project Define a holobranch named helm-chart that outputs the contents of the helm-chart/ directory Create a GitHub Actions workflow triggered by v* tags to build and publish a Docker container image to the project\u2019s GitHub Packages Create project deployment directory \u00b6 Within the shared cluster\u2019s GitHub repository, create a top-level directory naming this project deployment: mkdir client-project Set up release values \u00b6 Inside the project deployment directory created in the cluster\u2019s repository above, create a YAML file to hold deployment-specific overrides to the Helm chart\u2019s values.yaml , including at least the current image+tag: client-project/release.yaml image : docker.pkg.github.com/jarvusinnovations/client-project/client-project:v1.2.3\" This will be where the image version gets bumped to deploy new versions to the shared cluster. You can add any other instance-specific overrides like hostnames as well. Populate deployment directory with project\u2019s helm-chart projection \u00b6 Still within the shared cluster\u2019s GitHub repository, define a holosource and holomapping to populate the project\u2019s directory created above with content from the project\u2019s helm-chart projection: .holo/sources/client-project.toml [holosource] url = \"https://github.com/JarvusInnovations/client-project.git\" ref = \"refs/heads/deploy\" .holo/branches/k8s-manifests/client-project.toml [holomapping] holosource = \"=>helm-chart\" files = \"**\" During the projection of the cluster\u2019s k8s-manifests holobranch, the client-project directory will be populated from the remote helm-chart holobranch from the client-project holosource. The identically-named directory within the cluster\u2019s repository is then overlaid on top via an existing holomapping to copy all the cluster repository\u2019s overrides with after = \"*\" configured. Test composition \u00b6 To test the set up so far, project the k8s-manifests holobranch without lensing and list the full contents of the resulting project deployment directory: git ls-tree -r $( git holo project --working --no-lens k8s-manifests ) :client-project The output should include Chart.yaml , values.yaml , and templates/ from the project repository\u2019s helm-chart sources, plus the release.yaml file from the shared cluster repository\u2019s overrides directory: info: indexing working tree (this can take a while under Docker)... ... info: writing final output tree... info: projection ready 100644 blob 539bef2f8faea713a589ffabf97f094314faaf44 Chart.yaml 100644 blob dbf8c7a6ffc8edd87788ef885adf68cbf556f238 release.yaml 100644 blob dfcff8182969fe2db44037ed1c3a582b362bcdcc templates/_helpers.tpl 100644 blob e7e1a8bbbb63dc859dbf283557c413ae3e7c776f templates/cronjob.yaml 100644 blob 8fd6234ea1b1e2b04e469ef8ea31a860ec068901 templates/deployment.yaml 100644 blob b0c972120c53b742397d9032a8e14222b2aa14ef templates/ingress.yaml 100644 blob 0b2daeff5d1416eb981d6fa03dba5eabbebb6e73 templates/pvc.yaml 100644 blob 51ecaa3981401a8f20f56c458d92a9e46a3b3b8c templates/service.yaml 100644 blob 9a7fb93863e295ee8f059f3607840d7bf222b98d values.yaml Define hololens to build chart \u00b6 Finally, define a lens that uses helm template to transform the combined Helm chart content to deploy-ready Kubernetes manifests: .holo/lenses/client-project.toml [hololens] package = \"holo/lens-helm3/1.2\" [hololens.input] root = \"client-project\" files = \"**\" [hololens.output] merge = \"replace\" [hololens.helm] release_name = \"client-project\" namespace = \"client\" namespace_fill = true chart_path = \".\" value_files = [ \"values.yaml\" , \"release.yaml\" ] Test composition+lensing \u00b6 To test the full manifest generation process, first sync your local k8s/deploy branch to the current remote version: git update-ref refs/heads/k8s/deploy origin/k8s/deploy Then commit the projected k8s-manifests holobranch with lensing on top to preview how it will be extended: git holo project k8s-manifests-github --working --commit-to = k8s/deploy Add GitHub credentials to new namespace \u00b6 Authentication is always required to pull Docker images from GitHub Packages, even when the project repository is public. Wherever the project\u2019s Helm chart templates reference the project\u2019s Docker container image published on GitHub, imagePullSecrets should be configured to use a secret named regcred . The shared cluster\u2019s .github/workflows/deploy-manifests.yml workflow must then be edited to add a line with the new project namespace to the REGCRED_NAMESPACES env value. With that, the workflow will handle generating a regcred secret with access to GitHub in each namespace to include in every deployment. Authenticate access to private project sources \u00b6 If the project\u2019s repository is private, an additional step must be taken to grant fetch access to the GitHub Actions workflow running under the shared cluster\u2019s repository. Edit the shared cluster\u2019s .github/workflows/build-manifests.yml workflow and add an environment variable to the manifests projection step overriding the named source with an authenticated Git remote URL: # ... jobs : build-manifests : # ... steps : - name : 'Update holobranch: k8s/manifests' uses : JarvusInnovations/hologit@actions/projector/v1 env : # ... HOLO_SOURCE_CLIENT_PROJECT : https://jarvus-bot:${{ secrets.BOT_GITHUB_TOKEN }}@github.com/JarvusInnovations/client-project.git The bot user must be granted read access to the repository.","title":"Deploying a project"},{"location":"kubernetes/shared-clusters/deploy-project/#deploying-a-project","text":"","title":"Deploying a project"},{"location":"kubernetes/shared-clusters/deploy-project/#prerequisites","text":"A working Dockerfile at the root of the project repository","title":"Prerequisites"},{"location":"kubernetes/shared-clusters/deploy-project/#setup","text":"","title":"Setup"},{"location":"kubernetes/shared-clusters/deploy-project/#publish-docker-container-via-github","text":"Within the project\u2019s GitHub repository: Build a Helm 3 chart at in a helm-chart/ directory at the root of the project Define a holobranch named helm-chart that outputs the contents of the helm-chart/ directory Create a GitHub Actions workflow triggered by v* tags to build and publish a Docker container image to the project\u2019s GitHub Packages","title":"Publish Docker container via GitHub"},{"location":"kubernetes/shared-clusters/deploy-project/#create-project-deployment-directory","text":"Within the shared cluster\u2019s GitHub repository, create a top-level directory naming this project deployment: mkdir client-project","title":"Create project deployment directory"},{"location":"kubernetes/shared-clusters/deploy-project/#set-up-release-values","text":"Inside the project deployment directory created in the cluster\u2019s repository above, create a YAML file to hold deployment-specific overrides to the Helm chart\u2019s values.yaml , including at least the current image+tag: client-project/release.yaml image : docker.pkg.github.com/jarvusinnovations/client-project/client-project:v1.2.3\" This will be where the image version gets bumped to deploy new versions to the shared cluster. You can add any other instance-specific overrides like hostnames as well.","title":"Set up release values"},{"location":"kubernetes/shared-clusters/deploy-project/#populate-deployment-directory-with-projects-helm-chart-projection","text":"Still within the shared cluster\u2019s GitHub repository, define a holosource and holomapping to populate the project\u2019s directory created above with content from the project\u2019s helm-chart projection: .holo/sources/client-project.toml [holosource] url = \"https://github.com/JarvusInnovations/client-project.git\" ref = \"refs/heads/deploy\" .holo/branches/k8s-manifests/client-project.toml [holomapping] holosource = \"=>helm-chart\" files = \"**\" During the projection of the cluster\u2019s k8s-manifests holobranch, the client-project directory will be populated from the remote helm-chart holobranch from the client-project holosource. The identically-named directory within the cluster\u2019s repository is then overlaid on top via an existing holomapping to copy all the cluster repository\u2019s overrides with after = \"*\" configured.","title":"Populate deployment directory with project's helm-chart projection"},{"location":"kubernetes/shared-clusters/deploy-project/#test-composition","text":"To test the set up so far, project the k8s-manifests holobranch without lensing and list the full contents of the resulting project deployment directory: git ls-tree -r $( git holo project --working --no-lens k8s-manifests ) :client-project The output should include Chart.yaml , values.yaml , and templates/ from the project repository\u2019s helm-chart sources, plus the release.yaml file from the shared cluster repository\u2019s overrides directory: info: indexing working tree (this can take a while under Docker)... ... info: writing final output tree... info: projection ready 100644 blob 539bef2f8faea713a589ffabf97f094314faaf44 Chart.yaml 100644 blob dbf8c7a6ffc8edd87788ef885adf68cbf556f238 release.yaml 100644 blob dfcff8182969fe2db44037ed1c3a582b362bcdcc templates/_helpers.tpl 100644 blob e7e1a8bbbb63dc859dbf283557c413ae3e7c776f templates/cronjob.yaml 100644 blob 8fd6234ea1b1e2b04e469ef8ea31a860ec068901 templates/deployment.yaml 100644 blob b0c972120c53b742397d9032a8e14222b2aa14ef templates/ingress.yaml 100644 blob 0b2daeff5d1416eb981d6fa03dba5eabbebb6e73 templates/pvc.yaml 100644 blob 51ecaa3981401a8f20f56c458d92a9e46a3b3b8c templates/service.yaml 100644 blob 9a7fb93863e295ee8f059f3607840d7bf222b98d values.yaml","title":"Test composition"},{"location":"kubernetes/shared-clusters/deploy-project/#define-hololens-to-build-chart","text":"Finally, define a lens that uses helm template to transform the combined Helm chart content to deploy-ready Kubernetes manifests: .holo/lenses/client-project.toml [hololens] package = \"holo/lens-helm3/1.2\" [hololens.input] root = \"client-project\" files = \"**\" [hololens.output] merge = \"replace\" [hololens.helm] release_name = \"client-project\" namespace = \"client\" namespace_fill = true chart_path = \".\" value_files = [ \"values.yaml\" , \"release.yaml\" ]","title":"Define hololens to build chart"},{"location":"kubernetes/shared-clusters/deploy-project/#test-compositionlensing","text":"To test the full manifest generation process, first sync your local k8s/deploy branch to the current remote version: git update-ref refs/heads/k8s/deploy origin/k8s/deploy Then commit the projected k8s-manifests holobranch with lensing on top to preview how it will be extended: git holo project k8s-manifests-github --working --commit-to = k8s/deploy","title":"Test composition+lensing"},{"location":"kubernetes/shared-clusters/deploy-project/#add-github-credentials-to-new-namespace","text":"Authentication is always required to pull Docker images from GitHub Packages, even when the project repository is public. Wherever the project\u2019s Helm chart templates reference the project\u2019s Docker container image published on GitHub, imagePullSecrets should be configured to use a secret named regcred . The shared cluster\u2019s .github/workflows/deploy-manifests.yml workflow must then be edited to add a line with the new project namespace to the REGCRED_NAMESPACES env value. With that, the workflow will handle generating a regcred secret with access to GitHub in each namespace to include in every deployment.","title":"Add GitHub credentials to new namespace"},{"location":"kubernetes/shared-clusters/deploy-project/#authenticate-access-to-private-project-sources","text":"If the project\u2019s repository is private, an additional step must be taken to grant fetch access to the GitHub Actions workflow running under the shared cluster\u2019s repository. Edit the shared cluster\u2019s .github/workflows/build-manifests.yml workflow and add an environment variable to the manifests projection step overriding the named source with an authenticated Git remote URL: # ... jobs : build-manifests : # ... steps : - name : 'Update holobranch: k8s/manifests' uses : JarvusInnovations/hologit@actions/projector/v1 env : # ... HOLO_SOURCE_CLIENT_PROJECT : https://jarvus-bot:${{ secrets.BOT_GITHUB_TOKEN }}@github.com/JarvusInnovations/client-project.git The bot user must be granted read access to the repository.","title":"Authenticate access to private project sources"}]}